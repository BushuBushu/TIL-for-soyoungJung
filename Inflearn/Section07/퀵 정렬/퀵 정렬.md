# 퀵 정렬

> ### 개념

Devide and Conquer의 방식으로 정렬을 수행한다.

전위순회의 방식으로 병합정렬과 다르게 **본연의 일(=파티션 작업)을 먼저**하고 가지를 뻗는다.

또한 항상 정가운데를 기준으로 분할하는 병합정렬과 달리 **pivot**이라는 임의의 기준값을 사용한다.

pivot은 배열의 처음/중간/끝 등이 될 수 있다.



> ### 동작 흐름

1. 본연의 일 = pivot값을 기준으로 파티션을 나눠서, 
   - 왼쪽에는 pivot보다 작은 값(왼쪽의 리스트는 정렬 x. pivot보다 작기만 하면 됨. 어차피 계속 분할해서 동일한 작업을 하기 때문.)
   - 오른쪽에는 pivot보다 큰 값을 차례대로

2. 가지 뻗기(pivot을 기준으로 분할)
   - 왼쪽 가지: pivot의 왼쪽 리스트
   - 오른쪽 가지: pivot의 오른쪽 리스트
3. 한개짜리 까지 분할하면 정렬이 끝난 상태가 됨.

![image](https://user-images.githubusercontent.com/68037174/110909442-6e3dcc00-8353-11eb-8be2-b2e9fb148b6a.png)

위와 같이 pivot 값보다 작은 값들은 모두 왼편으로 몰고, 큰 값들은 모두 오른편으로 몰면 기준값은 정확히 정렬된 위치에 놓이게 됩니다. 또한 이런 방식으로 분할을 해놓으면 앞으로 더 이상 왼편에 있는 값들과 오른편에 있는 값들 간에는 비교를 할 필요가 없습니다. 따라서 반대편은 전혀 신경쓰지 않고 왼편이든 오른편이든 같은편 내의 값들 끼리만 비교 후 정렬을 할 수 있게 됩니다.

> ### 코드 구현

```python
def Qsort(lt, rt):
    if lt < rt:
        #우리가 정렬하고자 하는, 주어진 리스트의 첫번째 인덱스. 분할된 영역의 시작지점.
        pos = lt
        #pivot을 가장 오른쪽 값으로 잡음.
        pivot = arr[rt]
        for i in range(lt, rt):
            #해당 리스트에서 pivot보다 작거나 같은 값을 모두 왼쪽으로 옮기기. = swap하기(i의 값과 "pos의 값")
            #
            if arr[i] <= pivot:
                arr[i], arr[pos] = arr[pos], arr[i]
                #swap후에는 pos값이 1 증가, 즉 계속 탐색.
                pos += 1
        #주어진 리스트를 모두 탐색했다면 rt값과 pos값을 swap.
        arr[rt], arr[pos] = arr[pos], arr[rt] 
        Qsort(lt, pos-1)
        Qsort(pos + 1, rt)

if __name__ == '__main__':
    arr = [45, 21, 23, 36, 15, 67, 11, 60, 20, 33]
    Qsort(0, 9)
```

