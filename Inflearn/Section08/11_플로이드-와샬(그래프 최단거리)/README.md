# 문제번호. 문제제목

## 문제 내용


| 난이도 | 정답률(\_%) |
| :----: | :---------: |
|        |             |

## 설계(풀이 방식)
- dis 2차원 테이블


- 중간 노드를 낀 거리 구하기
    ```python
    for k in range(1, n + 1):        
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])
    ```

## 강의 해설
- 생각해야 할 포인트
    > 중간지점을 지나는 순서는 순열의 순서 - 순차적이지 않을 수 있다.
    예를 들어 노드 5에서 4으로 가는 방법 중, 중간 지점 1, 2, 3이 있다면 중간지점의 순서는 1-2-3 뿐만 아니라 3-1-2, 혹은 3-2-1 등이 될 수 있다. 
    why? 중간에 5에서 4으로 가는 길에 중간 지점 노드가 있을 수도 있기 때문.
        
    
    > 중복적용되지 않는다.
    예를 들어 K가 3일 때 5번 노드에서 4번 노드로 간다고 했을 때, `dis[5][3]`과 `dis[3][4]`를 이용해야 하는데, 이미 `dis[5][3]`과 `dis[3][4]`는 k인 3에 대해서 적용된 값이 아니냐고 생각할 수 있다. 이미 k가 적용된 값을 사용하면 안되지 않느냐고 생각할 수 있음. 
    **괜찮은 이유**
    `dis[5][3]`에서 k값에 대해 적용해볼 때, 5 -> 3 -> 3임. 즉, 5에서 3은 1, 2만 적용된 상태고(즉, 자기 자신), 3에서 3은 어차피 0임. --> 즉, 적용되지 않은 상태라서 중복 X.

## 배운 개념 및 깨달은 점
- 플로이드-와샬 알고리즘

    모든 정점 사이의 최단 경로를 찾는 탐색 알고리즘.

    > 과정
    1. 하나의 정점에서 다른 정점으로 바로 갈 수 있음녀 최소비용, 갈 수 없다면 INF로 배열에 값을 저장
    2. 3중 for문을 통해 거쳐가는 정점(k)을 설정 후, 해당 정점을 거쳐 비용이 줄어드는 경웽는 값을 바꿔줌
    3. 위 과정을 반복해(k번, 즉 각 노드마다) 최단 경로를 탐색.

> 참고
https://it-garden.tistory.com/247

## 정리

| 내 코드 (ms) | 빠른 코드 (ms) |
| :----------: | :------------: |
|              |                |

## 고생한 점